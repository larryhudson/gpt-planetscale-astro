---
import Layout from "@src/components/Layout.astro";
import * as db from "@src/utils/db";

const idParam = Astro.params.id;
if (!idParam) return Astro.redirect("/conversations");

const id = parseInt(idParam);

if (Astro.request.method === "POST") {
  const formData = await Astro.request.formData();
  const type = formData.get("type");
  const action = formData.get("action") || "addMessage";
  if (action === "getGptMessage") {
    await db.getGptMessageForConversation(id);
  } else {
    const content = formData.get("content");
    const messageData = {
      type,
      content,
      conversation_id: id,
    } as db.Message;
    await db.createMessage(messageData);
  }
}

const conversation = await db.getConversationById(id);
const messages = await db.getMessagesForConversation(id);
const systemPrompt = await db.getSystemPromptById(
  conversation.system_prompt_id
);

const messagesInGptFormat = [
  {
    role: "system",
    content: systemPrompt.content,
  },
  ...messages.map((message) => {
    return {
      role: message.type,
      content: message.content,
    };
  }),
];
---

<Layout>
  <h1>Conversation: {conversation.name}</h1>

  <div id="messages">
    {
      messages.map((message) => (
        <section data-message-container>
          <strong>{message.type}</strong>:{" "}
          <span data-content>{message.content}</span>
          <button data-action="speak" type="button">
            Speak
          </button>
        </section>
      ))
    }
  </div>

  <div
    id="previous-messages-data"
    data-messages={JSON.stringify(messagesInGptFormat)}
  >
  </div>

  <div id="current-chat">
    <p id="current-chat-content"></p>
  </div>

  <form method="POST">
    <button type="submit" name="action" value="getGptMessage"
      >Get GPT response</button
    >
  </form>

  <form id="new-message-form" method="POST">
    <input type="hidden" name="type" value="user" />

    <div class="buttons">
      <button type="button" data-action="record">ðŸŽ¤ Record</button>
      <button type="button" data-action="clear">Clear</button>
    </div>

    <label>
      Write your message:
      <textarea id="new-message" name="content"></textarea>
    </label>
    <button type="submit">Add</button>
  </form>

  <script>
    import AudioRecorder from "audio-recorder-polyfill";
    window.MediaRecorder = AudioRecorder;

    const selectButtons = document.querySelectorAll("[data-action=select]");
    selectButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const contentElement =
          button.parentElement.querySelector("[data-content]");
        window.getSelection().selectAllChildren(contentElement);
      });
    });

    const recordButton = document.querySelector("[data-action=record]");
    recordButton.addEventListener("click", () => {
      if (window.mediaRecorder.state === "recording") {
        stopRecording();
      } else if (window.mediaRecorder.state === "inactive") {
        startRecording();
      }
    });

    async function initialiseRecorder() {
      // set up audio recorder and assign to global variable
      const audioStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: false,
      });

      let mimetype = "audio/webm";
      window.mediaFileExt = "webm";

      try {
        window.mediaRecorder = new MediaRecorder(audioStream, {
          mimeType: mimetype,
        });
      } catch (err) {
        mimetype = "video/mp4";
        window.mediaFileExt = "mp4";
        window.mediaRecorder = new MediaRecorder(audioStream, {
          mimeType: mimetype,
        });
      }

      const audioChunks = [];
      window.audioChunks = audioChunks;

      window.mediaRecorder.addEventListener("dataavailable", (event) => {
        audioChunks.push(event.data);
      });

      window.mediaRecorder.addEventListener("stop", async () => {
        const audioBlob = new Blob(audioChunks);

        // make formData
        const formData = new FormData();
        const file = new File([audioBlob], "audio", {
          type: mimetype,
        });
        formData.append("file", file);
        formData.append("fileExt", window.mediaFileExt);

        // send formData to /api/transcribe
        const response = await fetch("/api/transcribe", {
          method: "POST",
          body: formData,
        });
        const data = await response.json();
        const newMessageTextarea = document.querySelector(
          "#new-message"
        ) as HTMLTextAreaElement;

        // if there's already text in the textarea, add a new line
        if (newMessageTextarea.value) {
          newMessageTextarea.value += "\n";
        }

        newMessageTextarea.value += data.text;

        // clear the recorder
        audioChunks.length = 0;
      });
    }

    initialiseRecorder();

    async function startRecording() {
      window.mediaRecorder.start();
      recordButton.textContent = "â¹ï¸ Stop";
    }

    async function stopRecording() {
      window.mediaRecorder.stop();
      recordButton.textContent = "ðŸŽ¤ Record";
    }

    // clear button should clear the input
    const clearButton = document.querySelector("[data-action=clear]");
    clearButton.addEventListener("click", () => {
      const newMessageTextarea = document.querySelector(
        "#new-message"
      ) as HTMLTextAreaElement;
      newMessageTextarea.value = "";
    });
  </script>
  <script>
    const speakButtons = Array.from(
      document.querySelectorAll("[data-action='speak']")
    );

    speakButtons.forEach((button) => {
      button.addEventListener("click", async () => {
        const container = button.closest("[data-message-container]");

        const content = container.querySelector("[data-content]").textContent;

        speakContent(content);
      });
    });

    async function speakContent(content) {
      // send content to tts API URL
      const ttsApiUrl = `/api/tts`;

      const audioResponse = await fetch(ttsApiUrl, {
        method: "POST",
        body: JSON.stringify({
          text: content,
        }),
        headers: {
          "Content-Type": "application/json",
        },
      });

      console.log(audioResponse);

      // add the audioResponse to the mediastream
      const blob = await audioResponse.blob();

      const audio = new Audio();
      audio.src = URL.createObjectURL(blob);
      audio.play();
    }
  </script>
</Layout>

<style>
  section {
    margin-bottom: 1rem;
  }

  textarea {
    display: block;
    width: 100%;
  }

  /* styles for chat interface */
  #messages {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow-y: scroll;
  }

  #messages section {
    margin-bottom: 1rem;
  }

  /* keep new message form fixed at bottom of screen */
  #new-message-form {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: 800px;
    margin: 0 auto;
    padding: 1rem;
    background: white;
    display: flex;
    flex-direction: column;
  }

  /* add padding so that the fixed item isn't overlapping anything */
  body {
    padding-bottom: 300px;
  }

  #new-message-form textarea {
    height: 100px;
  }

  #new-message-form button {
    margin-top: 1rem;
  }

  #current-chat-content {
    font-weight: bold;
  }

  /* make buttons big and clickable */
  button {
    padding: 1rem;
    font-size: 1.5rem;
  }

  button:active {
    background: #eee;
  }

  button:focus {
    outline: none;
  }

  button:disabled {
    opacity: 0.5;
  }

  /* show buttons side by side, 50% each */
  .buttons {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
  }

  input[type="text"],
  input[type="number"],
  textarea {
    font-size: 16px;
  }
</style>
